(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[39],{

/***/ "./node_modules/bnc-onboard/dist/esm/trezor-05345fcc.js":
/*!**************************************************************!*\
  !*** ./node_modules/bnc-onboard/dist/esm/trezor-05345fcc.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar trezorIcon = \"\\n\\t<svg width=\\\"40px\\\" height=\\\"40px\\\" viewBox=\\\"0 0 114 166\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">\\n\\t\\t<g id=\\\"Styles\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\">\\n\\t\\t\\t<path d=\\\"M17,51.453125 L17,40 C17,17.90861 34.90861,-1.0658141e-14 57,-1.0658141e-14 C79.09139,-1.0658141e-14 97,17.90861 97,40 L97,51.453125 L113.736328,51.453125 L113.736328,139.193359 L57.5,166 L0,139.193359 L0,51.453125 L17,51.453125 Z M37,51.453125 L77,51.453125 L77,40 L76.9678398,40 C76.3750564,29.406335 67.6617997,21 57,21 C46.3382003,21 37.6249436,29.406335 37.0321602,40 L37,40 L37,51.453125 Z M23,72 L23,125 L56.8681641,140.966797 L91,125 L91,72 L23,72 Z\\\" id=\\\"Trezor-logo\\\" fill=\\\"currentColor\\\"></path>\\n\\t\\t</g>\\n\\t</svg>\\n\";\n\nfunction trezor(options) {\n  var rpcUrl = options.rpcUrl,\n      networkId = options.networkId,\n      email = options.email,\n      appUrl = options.appUrl,\n      preferred = options.preferred,\n      label = options.label,\n      iconSrc = options.iconSrc,\n      svg = options.svg;\n  return {\n    name: label || 'Trezor',\n    svg: svg || trezorIcon,\n    iconSrc: iconSrc,\n    wallet: function () {\n      var _wallet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(helpers) {\n        var BigNumber, networkName, resetWalletState, provider;\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                BigNumber = helpers.BigNumber, networkName = helpers.networkName, resetWalletState = helpers.resetWalletState;\n                _context4.next = 3;\n                return trezorProvider({\n                  rpcUrl: rpcUrl,\n                  networkId: networkId,\n                  email: email,\n                  appUrl: appUrl,\n                  BigNumber: BigNumber,\n                  networkName: networkName,\n                  resetWalletState: resetWalletState\n                });\n\n              case 3:\n                provider = _context4.sent;\n                return _context4.abrupt(\"return\", {\n                  provider: provider,\n                  \"interface\": {\n                    name: 'Trezor',\n                    connect: provider.enable,\n                    disconnect: provider.disconnect,\n                    address: {\n                      get: function () {\n                        var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                          return regeneratorRuntime.wrap(function _callee$(_context) {\n                            while (1) {\n                              switch (_context.prev = _context.next) {\n                                case 0:\n                                  return _context.abrupt(\"return\", provider.getPrimaryAddress());\n\n                                case 1:\n                                case \"end\":\n                                  return _context.stop();\n                              }\n                            }\n                          }, _callee);\n                        }));\n\n                        function get() {\n                          return _get.apply(this, arguments);\n                        }\n\n                        return get;\n                      }()\n                    },\n                    network: {\n                      get: function () {\n                        var _get2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n                          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                            while (1) {\n                              switch (_context2.prev = _context2.next) {\n                                case 0:\n                                  return _context2.abrupt(\"return\", networkId);\n\n                                case 1:\n                                case \"end\":\n                                  return _context2.stop();\n                              }\n                            }\n                          }, _callee2);\n                        }));\n\n                        function get() {\n                          return _get2.apply(this, arguments);\n                        }\n\n                        return get;\n                      }()\n                    },\n                    balance: {\n                      get: function () {\n                        var _get3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n                          var address;\n                          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                            while (1) {\n                              switch (_context3.prev = _context3.next) {\n                                case 0:\n                                  address = provider.getPrimaryAddress();\n                                  return _context3.abrupt(\"return\", address && provider.getBalance(address));\n\n                                case 2:\n                                case \"end\":\n                                  return _context3.stop();\n                              }\n                            }\n                          }, _callee3);\n                        }));\n\n                        function get() {\n                          return _get3.apply(this, arguments);\n                        }\n\n                        return get;\n                      }()\n                    }\n                  }\n                });\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function wallet(_x) {\n        return _wallet.apply(this, arguments);\n      }\n\n      return wallet;\n    }(),\n    type: 'hardware',\n    desktop: true,\n    mobile: true,\n    osExclusions: ['iOS'],\n    preferred: preferred\n  };\n}\n\nfunction trezorProvider(_x2) {\n  return _trezorProvider.apply(this, arguments);\n}\n\nfunction _trezorProvider() {\n  _trezorProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(options) {\n    var TrezorConnectLibrary, EthereumTx, ethUtil, _yield$import, createProvider, _yield$import2, generateAddresses, isValidPath, TrezorConnect, DEVICE_EVENT, DEVICE, TREZOR_DEFAULT_PATH, networkId, email, appUrl, rpcUrl, BigNumber, networkName, resetWalletState, dPath, addressToPath, enabled, customPath, account, provider, disconnect, setPath, _setPath, isCustomPath, enable, getAddress, _getAddress, addresses, setPrimaryAccount, getPublicKey, _getPublicKey, getPrimaryAddress, getMoreAccounts, _getMoreAccounts, _getAccounts, _getAccounts2, getBalances, getBalance, trezorSignTransaction, _signTransaction, _signTransaction2, _signMessage, _signMessage2;\n\n    return regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            _signMessage2 = function _signMessage4() {\n              _signMessage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(message) {\n                var _, address, path;\n\n                return regeneratorRuntime.wrap(function _callee12$(_context12) {\n                  while (1) {\n                    switch (_context12.prev = _context12.next) {\n                      case 0:\n                        if (!(addressToPath.size === 0)) {\n                          _context12.next = 3;\n                          break;\n                        }\n\n                        _context12.next = 3;\n                        return enable();\n\n                      case 3:\n                        _ = _slicedToArray(_toConsumableArray(addressToPath.entries())[0], 2), address = _[0], path = _[1];\n                        return _context12.abrupt(\"return\", new Promise(function (resolve, reject) {\n                          TrezorConnect.ethereumSignMessage({\n                            path: path,\n                            message: ethUtil.stripHexPrefix(message.data),\n                            hex: true\n                          }).then(function (response) {\n                            if (response.success) {\n                              if (response.payload.address !== ethUtil.toChecksumAddress(address)) {\n                                reject(new Error('signature doesnt match the right address'));\n                              }\n\n                              var signature = \"0x\".concat(response.payload.signature);\n                              resolve(signature);\n                            } else {\n                              reject(new Error(response.payload && response.payload.error || 'There was an error signing a message'));\n                            }\n                          });\n                        }));\n\n                      case 5:\n                      case \"end\":\n                        return _context12.stop();\n                    }\n                  }\n                }, _callee12);\n              }));\n              return _signMessage2.apply(this, arguments);\n            };\n\n            _signMessage = function _signMessage3(_x9) {\n              return _signMessage2.apply(this, arguments);\n            };\n\n            _signTransaction2 = function _signTransaction4() {\n              _signTransaction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(transactionData) {\n                var path, transaction, trezorResult, signature;\n                return regeneratorRuntime.wrap(function _callee11$(_context11) {\n                  while (1) {\n                    switch (_context11.prev = _context11.next) {\n                      case 0:\n                        if (!(addressToPath.size === 0)) {\n                          _context11.next = 3;\n                          break;\n                        }\n\n                        _context11.next = 3;\n                        return enable();\n\n                      case 3:\n                        path = _toConsumableArray(addressToPath.values())[0];\n                        transaction = new EthereumTx.Transaction(transactionData, {\n                          chain: networkName(networkId)\n                        });\n                        _context11.next = 7;\n                        return trezorSignTransaction(path, transactionData);\n\n                      case 7:\n                        trezorResult = _context11.sent;\n\n                        if (trezorResult.success) {\n                          _context11.next = 10;\n                          break;\n                        }\n\n                        throw new Error(trezorResult.payload.error);\n\n                      case 10:\n                        signature = trezorResult.payload;\n                        transaction.v = signature.v;\n                        transaction.r = signature.r;\n                        transaction.s = signature.s;\n                        return _context11.abrupt(\"return\", \"0x\".concat(transaction.serialize().toString('hex')));\n\n                      case 15:\n                      case \"end\":\n                        return _context11.stop();\n                    }\n                  }\n                }, _callee11);\n              }));\n              return _signTransaction2.apply(this, arguments);\n            };\n\n            _signTransaction = function _signTransaction3(_x8) {\n              return _signTransaction2.apply(this, arguments);\n            };\n\n            trezorSignTransaction = function _trezorSignTransactio(path, transactionData) {\n              var nonce = transactionData.nonce,\n                  gasPrice = transactionData.gasPrice,\n                  gas = transactionData.gas,\n                  to = transactionData.to,\n                  value = transactionData.value,\n                  data = transactionData.data;\n              return TrezorConnect.ethereumSignTransaction({\n                path: path,\n                transaction: {\n                  nonce: nonce,\n                  gasPrice: gasPrice,\n                  gasLimit: gas,\n                  to: to,\n                  value: value || '',\n                  data: data || '',\n                  chainId: networkId\n                }\n              });\n            };\n\n            getBalance = function _getBalance(address) {\n              return new Promise(function (resolve, reject) {\n                provider.sendAsync({\n                  jsonrpc: '2.0',\n                  method: 'eth_getBalance',\n                  params: [address, 'latest'],\n                  id: 42\n                }, function (e, res) {\n                  e && reject(e);\n                  var result = res && res.result;\n\n                  if (result != null) {\n                    resolve(new BigNumber(result).toString(10));\n                  } else {\n                    resolve(null);\n                  }\n                });\n              });\n            };\n\n            getBalances = function _getBalances(addresses) {\n              return Promise.all(addresses.map(function (address) {\n                return new Promise( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(resolve) {\n                    var balance;\n                    return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.next = 2;\n                            return getBalance(address);\n\n                          case 2:\n                            balance = _context5.sent;\n                            resolve({\n                              address: address,\n                              balance: balance\n                            });\n\n                          case 4:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5);\n                  }));\n\n                  return function (_x7) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }());\n              }));\n            };\n\n            _getAccounts2 = function _getAccounts4() {\n              _getAccounts2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(getMore) {\n                var addressInfo;\n                return regeneratorRuntime.wrap(function _callee10$(_context10) {\n                  while (1) {\n                    switch (_context10.prev = _context10.next) {\n                      case 0:\n                        if (enabled) {\n                          _context10.next = 2;\n                          break;\n                        }\n\n                        return _context10.abrupt(\"return\", [undefined]);\n\n                      case 2:\n                        if (!(addressToPath.size > 0 && !getMore)) {\n                          _context10.next = 4;\n                          break;\n                        }\n\n                        return _context10.abrupt(\"return\", addresses());\n\n                      case 4:\n                        if (dPath === '') {\n                          dPath = TREZOR_DEFAULT_PATH;\n                        }\n\n                        if (account) {\n                          _context10.next = 15;\n                          break;\n                        }\n\n                        _context10.prev = 6;\n                        _context10.next = 9;\n                        return getPublicKey();\n\n                      case 9:\n                        account = _context10.sent;\n                        _context10.next = 15;\n                        break;\n\n                      case 12:\n                        _context10.prev = 12;\n                        _context10.t0 = _context10[\"catch\"](6);\n                        throw _context10.t0;\n\n                      case 15:\n                        addressInfo = generateAddresses(account, addressToPath.size);\n                        addressInfo.forEach(function (_ref4) {\n                          var dPath = _ref4.dPath,\n                              address = _ref4.address;\n                          addressToPath.set(address, dPath);\n                        });\n                        return _context10.abrupt(\"return\", addresses());\n\n                      case 18:\n                      case \"end\":\n                        return _context10.stop();\n                    }\n                  }\n                }, _callee10, null, [[6, 12]]);\n              }));\n              return _getAccounts2.apply(this, arguments);\n            };\n\n            _getAccounts = function _getAccounts3(_x6) {\n              return _getAccounts2.apply(this, arguments);\n            };\n\n            _getMoreAccounts = function _getMoreAccounts3() {\n              _getMoreAccounts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {\n                var accounts;\n                return regeneratorRuntime.wrap(function _callee9$(_context9) {\n                  while (1) {\n                    switch (_context9.prev = _context9.next) {\n                      case 0:\n                        _context9.next = 2;\n                        return _getAccounts(true);\n\n                      case 2:\n                        accounts = _context9.sent;\n                        return _context9.abrupt(\"return\", getBalances(accounts));\n\n                      case 4:\n                      case \"end\":\n                        return _context9.stop();\n                    }\n                  }\n                }, _callee9);\n              }));\n              return _getMoreAccounts.apply(this, arguments);\n            };\n\n            getMoreAccounts = function _getMoreAccounts2() {\n              return _getMoreAccounts.apply(this, arguments);\n            };\n\n            getPrimaryAddress = function _getPrimaryAddress() {\n              return enabled ? addresses()[0] : undefined;\n            };\n\n            _getPublicKey = function _getPublicKey3() {\n              _getPublicKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {\n                var result;\n                return regeneratorRuntime.wrap(function _callee8$(_context8) {\n                  while (1) {\n                    switch (_context8.prev = _context8.next) {\n                      case 0:\n                        if (dPath) {\n                          _context8.next = 2;\n                          break;\n                        }\n\n                        throw new Error('a derivation path is needed to get the public key');\n\n                      case 2:\n                        _context8.prev = 2;\n                        _context8.next = 5;\n                        return TrezorConnect.getPublicKey({\n                          path: dPath,\n                          coin: 'eth'\n                        });\n\n                      case 5:\n                        result = _context8.sent;\n\n                        if (result.success) {\n                          _context8.next = 8;\n                          break;\n                        }\n\n                        throw new Error(result.payload.error);\n\n                      case 8:\n                        account = {\n                          publicKey: result.payload.publicKey,\n                          chainCode: result.payload.chainCode,\n                          path: result.payload.serializedPath\n                        };\n                        return _context8.abrupt(\"return\", account);\n\n                      case 12:\n                        _context8.prev = 12;\n                        _context8.t0 = _context8[\"catch\"](2);\n                        throw new Error('There was an error accessing your Trezor accounts.');\n\n                      case 15:\n                      case \"end\":\n                        return _context8.stop();\n                    }\n                  }\n                }, _callee8, null, [[2, 12]]);\n              }));\n              return _getPublicKey.apply(this, arguments);\n            };\n\n            getPublicKey = function _getPublicKey2() {\n              return _getPublicKey.apply(this, arguments);\n            };\n\n            setPrimaryAccount = function _setPrimaryAccount(address) {\n              // make a copy and put in an array\n              var accounts = _toConsumableArray(addressToPath.entries());\n\n              var accountIndex = accounts.findIndex(function (_ref) {\n                var _ref2 = _slicedToArray(_ref, 1),\n                    accountAddress = _ref2[0];\n\n                return accountAddress === address;\n              }); // pull the item at the account index out of the array and place at the front\n\n              accounts.unshift(accounts.splice(accountIndex, 1)[0]); // reassign addressToPath to new ordered accounts\n\n              addressToPath = new Map(accounts);\n            };\n\n            addresses = function _addresses() {\n              return Array.from(addressToPath.keys());\n            };\n\n            _getAddress = function _getAddress3() {\n              _getAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(path) {\n                var errorMsg, result;\n                return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                  while (1) {\n                    switch (_context7.prev = _context7.next) {\n                      case 0:\n                        errorMsg = \"Unable to derive address from path \".concat(path);\n                        _context7.prev = 1;\n                        _context7.next = 4;\n                        return TrezorConnect.ethereumGetAddress({\n                          path: path,\n                          showOnTrezor: false\n                        });\n\n                      case 4:\n                        result = _context7.sent;\n\n                        if (result.success) {\n                          _context7.next = 7;\n                          break;\n                        }\n\n                        throw new Error(errorMsg);\n\n                      case 7:\n                        return _context7.abrupt(\"return\", result.payload.address);\n\n                      case 10:\n                        _context7.prev = 10;\n                        _context7.t0 = _context7[\"catch\"](1);\n                        throw new Error(errorMsg);\n\n                      case 13:\n                      case \"end\":\n                        return _context7.stop();\n                    }\n                  }\n                }, _callee7, null, [[1, 10]]);\n              }));\n              return _getAddress.apply(this, arguments);\n            };\n\n            getAddress = function _getAddress2(_x5) {\n              return _getAddress.apply(this, arguments);\n            };\n\n            enable = function _enable() {\n              enabled = true;\n              return _getAccounts();\n            };\n\n            isCustomPath = function _isCustomPath() {\n              return customPath;\n            };\n\n            _setPath = function _setPath3() {\n              _setPath = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(path, custom) {\n                var address;\n                return regeneratorRuntime.wrap(function _callee6$(_context6) {\n                  while (1) {\n                    switch (_context6.prev = _context6.next) {\n                      case 0:\n                        if (isValidPath(path)) {\n                          _context6.next = 2;\n                          break;\n                        }\n\n                        return _context6.abrupt(\"return\", false);\n\n                      case 2:\n                        if (path !== dPath) {\n                          // clear any exsting addresses if different path\n                          addressToPath = new Map();\n                        }\n\n                        if (!custom) {\n                          _context6.next = 17;\n                          break;\n                        }\n\n                        _context6.prev = 4;\n                        _context6.next = 7;\n                        return getAddress(path);\n\n                      case 7:\n                        address = _context6.sent;\n                        addressToPath.set(address, path);\n                        dPath = path;\n                        customPath = true;\n                        return _context6.abrupt(\"return\", true);\n\n                      case 14:\n                        _context6.prev = 14;\n                        _context6.t0 = _context6[\"catch\"](4);\n                        throw new Error(\"There was a problem deriving an address from path \".concat(path));\n\n                      case 17:\n                        customPath = false;\n                        dPath = path;\n                        return _context6.abrupt(\"return\", true);\n\n                      case 20:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }\n                }, _callee6, null, [[4, 14]]);\n              }));\n              return _setPath.apply(this, arguments);\n            };\n\n            setPath = function _setPath2(_x3, _x4) {\n              return _setPath.apply(this, arguments);\n            };\n\n            disconnect = function _disconnect() {\n              dPath = '';\n              addressToPath = new Map();\n              enabled = false;\n              provider.stop();\n            };\n\n            _context13.next = 25;\n            return __webpack_require__.e(/*! import() */ 8).then(__webpack_require__.t.bind(null, /*! trezor-connect */ \"./node_modules/trezor-connect/lib/index.js\", 7));\n\n          case 25:\n            TrezorConnectLibrary = _context13.sent;\n            _context13.next = 28;\n            return __webpack_require__.e(/*! import() */ 1).then(__webpack_require__.t.bind(null, /*! ethereumjs-tx */ \"./node_modules/bnc-onboard/node_modules/ethereumjs-tx/dist/index.js\", 7));\n\n          case 28:\n            EthereumTx = _context13.sent;\n            _context13.next = 31;\n            return __webpack_require__.e(/*! import() */ 3).then(__webpack_require__.t.bind(null, /*! ethereumjs-util */ \"./node_modules/bnc-onboard/node_modules/ethereumjs-util/dist/index.js\", 7));\n\n          case 31:\n            ethUtil = _context13.sent;\n            _context13.next = 34;\n            return __webpack_require__.e(/*! import() */ 0).then(__webpack_require__.bind(null, /*! ./providerEngine-597c2212.js */ \"./node_modules/bnc-onboard/dist/esm/providerEngine-597c2212.js\"));\n\n          case 34:\n            _yield$import = _context13.sent;\n            createProvider = _yield$import[\"default\"];\n            _context13.next = 38;\n            return __webpack_require__.e(/*! import() */ 2).then(__webpack_require__.bind(null, /*! ./hd-wallet-642b97e3.js */ \"./node_modules/bnc-onboard/dist/esm/hd-wallet-642b97e3.js\"));\n\n          case 38:\n            _yield$import2 = _context13.sent;\n            generateAddresses = _yield$import2.generateAddresses;\n            isValidPath = _yield$import2.isValidPath;\n            TrezorConnect = TrezorConnectLibrary[\"default\"], DEVICE_EVENT = TrezorConnectLibrary.DEVICE_EVENT, DEVICE = TrezorConnectLibrary.DEVICE;\n            TREZOR_DEFAULT_PATH = \"m/44'/60'/0'/0\";\n            networkId = options.networkId, email = options.email, appUrl = options.appUrl, rpcUrl = options.rpcUrl, BigNumber = options.BigNumber, networkName = options.networkName, resetWalletState = options.resetWalletState;\n            dPath = '';\n            addressToPath = new Map();\n            enabled = false;\n            customPath = false;\n            TrezorConnect.manifest({\n              email: email,\n              appUrl: appUrl\n            });\n            provider = createProvider({\n              getAccounts: function getAccounts(callback) {\n                _getAccounts().then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              signTransaction: function signTransaction(transactionData, callback) {\n                _signTransaction(transactionData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              processMessage: function processMessage(messageData, callback) {\n                _signMessage(messageData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              processPersonalMessage: function processPersonalMessage(messageData, callback) {\n                _signMessage(messageData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              signMessage: function signMessage(messageData, callback) {\n                _signMessage(messageData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              signPersonalMessage: function signPersonalMessage(messageData, callback) {\n                _signMessage(messageData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              rpcUrl: rpcUrl\n            });\n            TrezorConnect.on(DEVICE_EVENT, function (event) {\n              if (event.type === DEVICE.DISCONNECT) {\n                provider.stop();\n                resetWalletState({\n                  disconnected: true,\n                  walletName: 'Trezor'\n                });\n              }\n            });\n            provider.setPath = setPath;\n            provider.dPath = dPath;\n            provider.enable = enable;\n            provider.setPrimaryAccount = setPrimaryAccount;\n            provider.getPrimaryAddress = getPrimaryAddress;\n            provider.getAccounts = _getAccounts;\n            provider.getMoreAccounts = getMoreAccounts;\n            provider.getBalance = getBalance;\n            provider.getBalances = getBalances;\n            provider.send = provider.sendAsync;\n            provider.disconnect = disconnect;\n            provider.isCustomPath = isCustomPath;\n            return _context13.abrupt(\"return\", provider);\n\n          case 64:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return _trezorProvider.apply(this, arguments);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (trezor);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm5jLW9uYm9hcmQvZGlzdC9lc20vdHJlem9yLTA1MzQ1ZmNjLmpzPzljYjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSxpQ0FBaUMsMkhBQTJIOztBQUU1Siw2QkFBNkIsa0tBQWtLOztBQUUvTCx3Q0FBd0MsZ0ZBQWdGLGVBQWUsZUFBZSxnQkFBZ0Isb0JBQW9CLE1BQU0sMENBQTBDLCtCQUErQixhQUFhLHFCQUFxQixtQ0FBbUMsRUFBRSxFQUFFLGNBQWMsV0FBVyxVQUFVLEVBQUUsVUFBVSxNQUFNLGlEQUFpRCxFQUFFLFVBQVUsa0JBQWtCLEVBQUUsRUFBRSxhQUFhOztBQUV2ZSwrQkFBK0Isb0NBQW9DOztBQUVuRSxrQ0FBa0MscUhBQXFIOztBQUV2SiwrQkFBK0IsNkpBQTZKOztBQUU1TCxpREFBaUQsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRCxrSEFBa0g7O0FBRTlaLGlDQUFpQywrRkFBK0Y7O0FBRWhJLGtDQUFrQyx1REFBdUQ7O0FBRXpGLHNDQUFzQyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxrQkFBa0IsRUFBRSxhQUFhOztBQUVyTCw0RUFBNEUsTUFBTSwwQkFBMEIsd0JBQXdCLEVBQUUsZ0JBQWdCLGVBQWUsUUFBUSxFQUFFLGlCQUFpQixnQkFBZ0IsRUFBRSxPQUFPLDRDQUE0QyxFQUFFOztBQUV2USxnQ0FBZ0MscUJBQXFCLG1DQUFtQyxnREFBZ0QsZ0NBQWdDLHdCQUF3Qix3RUFBd0UsRUFBRSx1QkFBdUIsdUVBQXVFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxHQUFHOztBQUVuWTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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akIsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVlLHFFQUFNIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JuYy1vbmJvYXJkL2Rpc3QvZXNtL3RyZXpvci0wNTM0NWZjYy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbnZhciB0cmV6b3JJY29uID0gXCJcXG5cXHQ8c3ZnIHdpZHRoPVxcXCI0MHB4XFxcIiBoZWlnaHQ9XFxcIjQwcHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAxMTQgMTY2XFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiPlxcblxcdFxcdDxnIGlkPVxcXCJTdHlsZXNcXFwiIHN0cm9rZT1cXFwibm9uZVxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxXFxcIiBmaWxsPVxcXCJub25lXFxcIiBmaWxsLXJ1bGU9XFxcImV2ZW5vZGRcXFwiPlxcblxcdFxcdFxcdDxwYXRoIGQ9XFxcIk0xNyw1MS40NTMxMjUgTDE3LDQwIEMxNywxNy45MDg2MSAzNC45MDg2MSwtMS4wNjU4MTQxZS0xNCA1NywtMS4wNjU4MTQxZS0xNCBDNzkuMDkxMzksLTEuMDY1ODE0MWUtMTQgOTcsMTcuOTA4NjEgOTcsNDAgTDk3LDUxLjQ1MzEyNSBMMTEzLjczNjMyOCw1MS40NTMxMjUgTDExMy43MzYzMjgsMTM5LjE5MzM1OSBMNTcuNSwxNjYgTDAsMTM5LjE5MzM1OSBMMCw1MS40NTMxMjUgTDE3LDUxLjQ1MzEyNSBaIE0zNyw1MS40NTMxMjUgTDc3LDUxLjQ1MzEyNSBMNzcsNDAgTDc2Ljk2NzgzOTgsNDAgQzc2LjM3NTA1NjQsMjkuNDA2MzM1IDY3LjY2MTc5OTcsMjEgNTcsMjEgQzQ2LjMzODIwMDMsMjEgMzcuNjI0OTQzNiwyOS40MDYzMzUgMzcuMDMyMTYwMiw0MCBMMzcsNDAgTDM3LDUxLjQ1MzEyNSBaIE0yMyw3MiBMMjMsMTI1IEw1Ni44NjgxNjQxLDE0MC45NjY3OTcgTDkxLDEyNSBMOTEsNzIgTDIzLDcyIFpcXFwiIGlkPVxcXCJUcmV6b3ItbG9nb1xcXCIgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIj48L3BhdGg+XFxuXFx0XFx0PC9nPlxcblxcdDwvc3ZnPlxcblwiO1xuXG5mdW5jdGlvbiB0cmV6b3Iob3B0aW9ucykge1xuICB2YXIgcnBjVXJsID0gb3B0aW9ucy5ycGNVcmwsXG4gICAgICBuZXR3b3JrSWQgPSBvcHRpb25zLm5ldHdvcmtJZCxcbiAgICAgIGVtYWlsID0gb3B0aW9ucy5lbWFpbCxcbiAgICAgIGFwcFVybCA9IG9wdGlvbnMuYXBwVXJsLFxuICAgICAgcHJlZmVycmVkID0gb3B0aW9ucy5wcmVmZXJyZWQsXG4gICAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWwsXG4gICAgICBpY29uU3JjID0gb3B0aW9ucy5pY29uU3JjLFxuICAgICAgc3ZnID0gb3B0aW9ucy5zdmc7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbGFiZWwgfHwgJ1RyZXpvcicsXG4gICAgc3ZnOiBzdmcgfHwgdHJlem9ySWNvbixcbiAgICBpY29uU3JjOiBpY29uU3JjLFxuICAgIHdhbGxldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF93YWxsZXQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGhlbHBlcnMpIHtcbiAgICAgICAgdmFyIEJpZ051bWJlciwgbmV0d29ya05hbWUsIHJlc2V0V2FsbGV0U3RhdGUsIHByb3ZpZGVyO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIEJpZ051bWJlciA9IGhlbHBlcnMuQmlnTnVtYmVyLCBuZXR3b3JrTmFtZSA9IGhlbHBlcnMubmV0d29ya05hbWUsIHJlc2V0V2FsbGV0U3RhdGUgPSBoZWxwZXJzLnJlc2V0V2FsbGV0U3RhdGU7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmV6b3JQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgICBycGNVcmw6IHJwY1VybCxcbiAgICAgICAgICAgICAgICAgIG5ldHdvcmtJZDogbmV0d29ya0lkLFxuICAgICAgICAgICAgICAgICAgZW1haWw6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgYXBwVXJsOiBhcHBVcmwsXG4gICAgICAgICAgICAgICAgICBCaWdOdW1iZXI6IEJpZ051bWJlcixcbiAgICAgICAgICAgICAgICAgIG5ldHdvcmtOYW1lOiBuZXR3b3JrTmFtZSxcbiAgICAgICAgICAgICAgICAgIHJlc2V0V2FsbGV0U3RhdGU6IHJlc2V0V2FsbGV0U3RhdGVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlcjogcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImludGVyZmFjZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdUcmV6b3InLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0OiBwcm92aWRlci5lbmFibGUsXG4gICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IHByb3ZpZGVyLmRpc2Nvbm5lY3QsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZ2V0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBwcm92aWRlci5nZXRQcmltYXJ5QWRkcmVzcygpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldDtcbiAgICAgICAgICAgICAgICAgICAgICB9KClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazoge1xuICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9nZXQyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBuZXR3b3JrSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgIH0oKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBiYWxhbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2dldDMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gcHJvdmlkZXIuZ2V0UHJpbWFyeUFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBhZGRyZXNzICYmIHByb3ZpZGVyLmdldEJhbGFuY2UoYWRkcmVzcykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0My5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgIH0oKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHdhbGxldChfeCkge1xuICAgICAgICByZXR1cm4gX3dhbGxldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH0oKSxcbiAgICB0eXBlOiAnaGFyZHdhcmUnLFxuICAgIGRlc2t0b3A6IHRydWUsXG4gICAgbW9iaWxlOiB0cnVlLFxuICAgIG9zRXhjbHVzaW9uczogWydpT1MnXSxcbiAgICBwcmVmZXJyZWQ6IHByZWZlcnJlZFxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmV6b3JQcm92aWRlcihfeDIpIHtcbiAgcmV0dXJuIF90cmV6b3JQcm92aWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfdHJlem9yUHJvdmlkZXIoKSB7XG4gIF90cmV6b3JQcm92aWRlciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEzKG9wdGlvbnMpIHtcbiAgICB2YXIgVHJlem9yQ29ubmVjdExpYnJhcnksIEV0aGVyZXVtVHgsIGV0aFV0aWwsIF95aWVsZCRpbXBvcnQsIGNyZWF0ZVByb3ZpZGVyLCBfeWllbGQkaW1wb3J0MiwgZ2VuZXJhdGVBZGRyZXNzZXMsIGlzVmFsaWRQYXRoLCBUcmV6b3JDb25uZWN0LCBERVZJQ0VfRVZFTlQsIERFVklDRSwgVFJFWk9SX0RFRkFVTFRfUEFUSCwgbmV0d29ya0lkLCBlbWFpbCwgYXBwVXJsLCBycGNVcmwsIEJpZ051bWJlciwgbmV0d29ya05hbWUsIHJlc2V0V2FsbGV0U3RhdGUsIGRQYXRoLCBhZGRyZXNzVG9QYXRoLCBlbmFibGVkLCBjdXN0b21QYXRoLCBhY2NvdW50LCBwcm92aWRlciwgZGlzY29ubmVjdCwgc2V0UGF0aCwgX3NldFBhdGgsIGlzQ3VzdG9tUGF0aCwgZW5hYmxlLCBnZXRBZGRyZXNzLCBfZ2V0QWRkcmVzcywgYWRkcmVzc2VzLCBzZXRQcmltYXJ5QWNjb3VudCwgZ2V0UHVibGljS2V5LCBfZ2V0UHVibGljS2V5LCBnZXRQcmltYXJ5QWRkcmVzcywgZ2V0TW9yZUFjY291bnRzLCBfZ2V0TW9yZUFjY291bnRzLCBfZ2V0QWNjb3VudHMsIF9nZXRBY2NvdW50czIsIGdldEJhbGFuY2VzLCBnZXRCYWxhbmNlLCB0cmV6b3JTaWduVHJhbnNhY3Rpb24sIF9zaWduVHJhbnNhY3Rpb24sIF9zaWduVHJhbnNhY3Rpb24yLCBfc2lnbk1lc3NhZ2UsIF9zaWduTWVzc2FnZTI7XG5cbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEzJChfY29udGV4dDEzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9zaWduTWVzc2FnZTIgPSBmdW5jdGlvbiBfc2lnbk1lc3NhZ2U0KCkge1xuICAgICAgICAgICAgICBfc2lnbk1lc3NhZ2UyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBfLCBhZGRyZXNzLCBwYXRoO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhZGRyZXNzVG9QYXRoLnNpemUgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgXyA9IF9zbGljZWRUb0FycmF5KF90b0NvbnN1bWFibGVBcnJheShhZGRyZXNzVG9QYXRoLmVudHJpZXMoKSlbMF0sIDIpLCBhZGRyZXNzID0gX1swXSwgcGF0aCA9IF9bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBUcmV6b3JDb25uZWN0LmV0aGVyZXVtU2lnbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXRoVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UucGF5bG9hZC5hZGRyZXNzICE9PSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3NpZ25hdHVyZSBkb2VzbnQgbWF0Y2ggdGhlIHJpZ2h0IGFkZHJlc3MnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSBcIjB4XCIuY29uY2F0KHJlc3BvbnNlLnBheWxvYWQuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXNwb25zZS5wYXlsb2FkICYmIHJlc3BvbnNlLnBheWxvYWQuZXJyb3IgfHwgJ1RoZXJlIHdhcyBhbiBlcnJvciBzaWduaW5nIGEgbWVzc2FnZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUxMik7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zaWduTWVzc2FnZTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9zaWduTWVzc2FnZSA9IGZ1bmN0aW9uIF9zaWduTWVzc2FnZTMoX3g5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfc2lnbk1lc3NhZ2UyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfc2lnblRyYW5zYWN0aW9uMiA9IGZ1bmN0aW9uIF9zaWduVHJhbnNhY3Rpb240KCkge1xuICAgICAgICAgICAgICBfc2lnblRyYW5zYWN0aW9uMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKHRyYW5zYWN0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoLCB0cmFuc2FjdGlvbiwgdHJlem9yUmVzdWx0LCBzaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDExLnByZXYgPSBfY29udGV4dDExLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhZGRyZXNzVG9QYXRoLnNpemUgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IF90b0NvbnN1bWFibGVBcnJheShhZGRyZXNzVG9QYXRoLnZhbHVlcygpKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IEV0aGVyZXVtVHguVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25EYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluOiBuZXR3b3JrTmFtZShuZXR3b3JrSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJlem9yU2lnblRyYW5zYWN0aW9uKHBhdGgsIHRyYW5zYWN0aW9uRGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmV6b3JSZXN1bHQgPSBfY29udGV4dDExLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmV6b3JSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0cmV6b3JSZXN1bHQucGF5bG9hZC5lcnJvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gdHJlem9yUmVzdWx0LnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi52ID0gc2lnbmF0dXJlLnY7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5yID0gc2lnbmF0dXJlLnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zID0gc2lnbmF0dXJlLnM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgXCIweFwiLmNvbmNhdCh0cmFuc2FjdGlvbi5zZXJpYWxpemUoKS50b1N0cmluZygnaGV4JykpKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTExKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXR1cm4gX3NpZ25UcmFuc2FjdGlvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiBfc2lnblRyYW5zYWN0aW9uMyhfeDgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zaWduVHJhbnNhY3Rpb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0cmV6b3JTaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiBfdHJlem9yU2lnblRyYW5zYWN0aW8ocGF0aCwgdHJhbnNhY3Rpb25EYXRhKSB7XG4gICAgICAgICAgICAgIHZhciBub25jZSA9IHRyYW5zYWN0aW9uRGF0YS5ub25jZSxcbiAgICAgICAgICAgICAgICAgIGdhc1ByaWNlID0gdHJhbnNhY3Rpb25EYXRhLmdhc1ByaWNlLFxuICAgICAgICAgICAgICAgICAgZ2FzID0gdHJhbnNhY3Rpb25EYXRhLmdhcyxcbiAgICAgICAgICAgICAgICAgIHRvID0gdHJhbnNhY3Rpb25EYXRhLnRvLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0cmFuc2FjdGlvbkRhdGEudmFsdWUsXG4gICAgICAgICAgICAgICAgICBkYXRhID0gdHJhbnNhY3Rpb25EYXRhLmRhdGE7XG4gICAgICAgICAgICAgIHJldHVybiBUcmV6b3JDb25uZWN0LmV0aGVyZXVtU2lnblRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICBub25jZTogbm9uY2UsXG4gICAgICAgICAgICAgICAgICBnYXNQcmljZTogZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgICBnYXNMaW1pdDogZ2FzLFxuICAgICAgICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IG5ldHdvcmtJZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBnZXRCYWxhbmNlID0gZnVuY3Rpb24gX2dldEJhbGFuY2UoYWRkcmVzcykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnNlbmRBc3luYyh7XG4gICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9nZXRCYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgIHBhcmFtczogW2FkZHJlc3MsICdsYXRlc3QnXSxcbiAgICAgICAgICAgICAgICAgIGlkOiA0MlxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlLCByZXMpIHtcbiAgICAgICAgICAgICAgICAgIGUgJiYgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlcyAmJiByZXMucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgQmlnTnVtYmVyKHJlc3VsdCkudG9TdHJpbmcoMTApKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZ2V0QmFsYW5jZXMgPSBmdW5jdGlvbiBfZ2V0QmFsYW5jZXMoYWRkcmVzc2VzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChhZGRyZXNzZXMubWFwKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNShyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYWxhbmNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmFsYW5jZShhZGRyZXNzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZSA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2U6IGJhbGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU1KTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9nZXRBY2NvdW50czIgPSBmdW5jdGlvbiBfZ2V0QWNjb3VudHM0KCkge1xuICAgICAgICAgICAgICBfZ2V0QWNjb3VudHMyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoZ2V0TW9yZSkge1xuICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzSW5mbztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgW3VuZGVmaW5lZF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYWRkcmVzc1RvUGF0aC5zaXplID4gMCAmJiAhZ2V0TW9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCBhZGRyZXNzZXMoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZFBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRQYXRoID0gVFJFWk9SX0RFRkFVTFRfUEFUSDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLnByZXYgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNLZXkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnQgPSBfY29udGV4dDEwLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC50MCA9IF9jb250ZXh0MTBbXCJjYXRjaFwiXSg2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0MTAudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc0luZm8gPSBnZW5lcmF0ZUFkZHJlc3NlcyhhY2NvdW50LCBhZGRyZXNzVG9QYXRoLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc0luZm8uZm9yRWFjaChmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRQYXRoID0gX3JlZjQuZFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX3JlZjQuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1RvUGF0aC5zZXQoYWRkcmVzcywgZFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgYWRkcmVzc2VzKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMTAsIG51bGwsIFtbNiwgMTJdXSk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRBY2NvdW50czIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9nZXRBY2NvdW50cyA9IGZ1bmN0aW9uIF9nZXRBY2NvdW50czMoX3g2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0QWNjb3VudHMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfZ2V0TW9yZUFjY291bnRzID0gZnVuY3Rpb24gX2dldE1vcmVBY2NvdW50czMoKSB7XG4gICAgICAgICAgICAgIF9nZXRNb3JlQWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KCkge1xuICAgICAgICAgICAgICAgIHZhciBhY2NvdW50cztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRBY2NvdW50cyh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCBnZXRCYWxhbmNlcyhhY2NvdW50cykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTkpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0TW9yZUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBnZXRNb3JlQWNjb3VudHMgPSBmdW5jdGlvbiBfZ2V0TW9yZUFjY291bnRzMigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRNb3JlQWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGdldFByaW1hcnlBZGRyZXNzID0gZnVuY3Rpb24gX2dldFByaW1hcnlBZGRyZXNzKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZW5hYmxlZCA/IGFkZHJlc3NlcygpWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX2dldFB1YmxpY0tleSA9IGZ1bmN0aW9uIF9nZXRQdWJsaWNLZXkzKCkge1xuICAgICAgICAgICAgICBfZ2V0UHVibGljS2V5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIGRlcml2YXRpb24gcGF0aCBpcyBuZWVkZWQgdG8gZ2V0IHRoZSBwdWJsaWMga2V5Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHJlem9yQ29ubmVjdC5nZXRQdWJsaWNLZXkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBkUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29pbjogJ2V0aCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ4LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LnBheWxvYWQuZXJyb3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiByZXN1bHQucGF5bG9hZC5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluQ29kZTogcmVzdWx0LnBheWxvYWQuY2hhaW5Db2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiByZXN1bHQucGF5bG9hZC5zZXJpYWxpemVkUGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIGFjY291bnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgudDAgPSBfY29udGV4dDhbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIGFjY2Vzc2luZyB5b3VyIFRyZXpvciBhY2NvdW50cy4nKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlOCwgbnVsbCwgW1syLCAxMl1dKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXR1cm4gX2dldFB1YmxpY0tleS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gX2dldFB1YmxpY0tleTIoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0UHVibGljS2V5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzZXRQcmltYXJ5QWNjb3VudCA9IGZ1bmN0aW9uIF9zZXRQcmltYXJ5QWNjb3VudChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgIC8vIG1ha2UgYSBjb3B5IGFuZCBwdXQgaW4gYW4gYXJyYXlcbiAgICAgICAgICAgICAgdmFyIGFjY291bnRzID0gX3RvQ29uc3VtYWJsZUFycmF5KGFkZHJlc3NUb1BhdGguZW50cmllcygpKTtcblxuICAgICAgICAgICAgICB2YXIgYWNjb3VudEluZGV4ID0gYWNjb3VudHMuZmluZEluZGV4KGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRBZGRyZXNzID0gX3JlZjJbMF07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjb3VudEFkZHJlc3MgPT09IGFkZHJlc3M7XG4gICAgICAgICAgICAgIH0pOyAvLyBwdWxsIHRoZSBpdGVtIGF0IHRoZSBhY2NvdW50IGluZGV4IG91dCBvZiB0aGUgYXJyYXkgYW5kIHBsYWNlIGF0IHRoZSBmcm9udFxuXG4gICAgICAgICAgICAgIGFjY291bnRzLnVuc2hpZnQoYWNjb3VudHMuc3BsaWNlKGFjY291bnRJbmRleCwgMSlbMF0pOyAvLyByZWFzc2lnbiBhZGRyZXNzVG9QYXRoIHRvIG5ldyBvcmRlcmVkIGFjY291bnRzXG5cbiAgICAgICAgICAgICAgYWRkcmVzc1RvUGF0aCA9IG5ldyBNYXAoYWNjb3VudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYWRkcmVzc2VzID0gZnVuY3Rpb24gX2FkZHJlc3NlcygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYWRkcmVzc1RvUGF0aC5rZXlzKCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX2dldEFkZHJlc3MgPSBmdW5jdGlvbiBfZ2V0QWRkcmVzczMoKSB7XG4gICAgICAgICAgICAgIF9nZXRBZGRyZXNzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhwYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTXNnLCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTXNnID0gXCJVbmFibGUgdG8gZGVyaXZlIGFkZHJlc3MgZnJvbSBwYXRoIFwiLmNvbmNhdChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUcmV6b3JDb25uZWN0LmV0aGVyZXVtR2V0QWRkcmVzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dPblRyZXpvcjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ3LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LnBheWxvYWQuYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlNywgbnVsbCwgW1sxLCAxMF1dKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXR1cm4gX2dldEFkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGdldEFkZHJlc3MgPSBmdW5jdGlvbiBfZ2V0QWRkcmVzczIoX3g1KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0QWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZW5hYmxlID0gZnVuY3Rpb24gX2VuYWJsZSgpIHtcbiAgICAgICAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlzQ3VzdG9tUGF0aCA9IGZ1bmN0aW9uIF9pc0N1c3RvbVBhdGgoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjdXN0b21QYXRoO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX3NldFBhdGggPSBmdW5jdGlvbiBfc2V0UGF0aDMoKSB7XG4gICAgICAgICAgICAgIF9zZXRQYXRoID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNihwYXRoLCBjdXN0b20pIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkcmVzcztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRQYXRoKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoICE9PSBkUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBhbnkgZXhzdGluZyBhZGRyZXNzZXMgaWYgZGlmZmVyZW50IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1RvUGF0aCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHBhdGgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1RvUGF0aC5zZXQoYWRkcmVzcywgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkUGF0aCA9IHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21QYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhIHByb2JsZW0gZGVyaXZpbmcgYW4gYWRkcmVzcyBmcm9tIHBhdGggXCIuY29uY2F0KHBhdGgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21QYXRoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkUGF0aCA9IHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlNiwgbnVsbCwgW1s0LCAxNF1dKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXR1cm4gX3NldFBhdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNldFBhdGggPSBmdW5jdGlvbiBfc2V0UGF0aDIoX3gzLCBfeDQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zZXRQYXRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkaXNjb25uZWN0ID0gZnVuY3Rpb24gX2Rpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICAgIGRQYXRoID0gJyc7XG4gICAgICAgICAgICAgIGFkZHJlc3NUb1BhdGggPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcHJvdmlkZXIuc3RvcCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMjU7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0KCd0cmV6b3ItY29ubmVjdCcpO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIFRyZXpvckNvbm5lY3RMaWJyYXJ5ID0gX2NvbnRleHQxMy5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMjg7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0KCdldGhlcmV1bWpzLXR4Jyk7XG5cbiAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgRXRoZXJldW1UeCA9IF9jb250ZXh0MTMuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDMxO1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydCgnZXRoZXJldW1qcy11dGlsJyk7XG5cbiAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgZXRoVXRpbCA9IF9jb250ZXh0MTMuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDM0O1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydCgnLi9wcm92aWRlckVuZ2luZS01OTdjMjIxMi5qcycpO1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIF95aWVsZCRpbXBvcnQgPSBfY29udGV4dDEzLnNlbnQ7XG4gICAgICAgICAgICBjcmVhdGVQcm92aWRlciA9IF95aWVsZCRpbXBvcnRbXCJkZWZhdWx0XCJdO1xuICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMzg7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0KCcuL2hkLXdhbGxldC02NDJiOTdlMy5qcycpO1xuXG4gICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgIF95aWVsZCRpbXBvcnQyID0gX2NvbnRleHQxMy5zZW50O1xuICAgICAgICAgICAgZ2VuZXJhdGVBZGRyZXNzZXMgPSBfeWllbGQkaW1wb3J0Mi5nZW5lcmF0ZUFkZHJlc3NlcztcbiAgICAgICAgICAgIGlzVmFsaWRQYXRoID0gX3lpZWxkJGltcG9ydDIuaXNWYWxpZFBhdGg7XG4gICAgICAgICAgICBUcmV6b3JDb25uZWN0ID0gVHJlem9yQ29ubmVjdExpYnJhcnlbXCJkZWZhdWx0XCJdLCBERVZJQ0VfRVZFTlQgPSBUcmV6b3JDb25uZWN0TGlicmFyeS5ERVZJQ0VfRVZFTlQsIERFVklDRSA9IFRyZXpvckNvbm5lY3RMaWJyYXJ5LkRFVklDRTtcbiAgICAgICAgICAgIFRSRVpPUl9ERUZBVUxUX1BBVEggPSBcIm0vNDQnLzYwJy8wJy8wXCI7XG4gICAgICAgICAgICBuZXR3b3JrSWQgPSBvcHRpb25zLm5ldHdvcmtJZCwgZW1haWwgPSBvcHRpb25zLmVtYWlsLCBhcHBVcmwgPSBvcHRpb25zLmFwcFVybCwgcnBjVXJsID0gb3B0aW9ucy5ycGNVcmwsIEJpZ051bWJlciA9IG9wdGlvbnMuQmlnTnVtYmVyLCBuZXR3b3JrTmFtZSA9IG9wdGlvbnMubmV0d29ya05hbWUsIHJlc2V0V2FsbGV0U3RhdGUgPSBvcHRpb25zLnJlc2V0V2FsbGV0U3RhdGU7XG4gICAgICAgICAgICBkUGF0aCA9ICcnO1xuICAgICAgICAgICAgYWRkcmVzc1RvUGF0aCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGN1c3RvbVBhdGggPSBmYWxzZTtcbiAgICAgICAgICAgIFRyZXpvckNvbm5lY3QubWFuaWZlc3Qoe1xuICAgICAgICAgICAgICBlbWFpbDogZW1haWwsXG4gICAgICAgICAgICAgIGFwcFVybDogYXBwVXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gY3JlYXRlUHJvdmlkZXIoe1xuICAgICAgICAgICAgICBnZXRBY2NvdW50czogZnVuY3Rpb24gZ2V0QWNjb3VudHMoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfZ2V0QWNjb3VudHMoKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uRGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uRGF0YSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcm9jZXNzTWVzc2FnZTogZnVuY3Rpb24gcHJvY2Vzc01lc3NhZ2UobWVzc2FnZURhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX3NpZ25NZXNzYWdlKG1lc3NhZ2VEYXRhKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHByb2Nlc3NQZXJzb25hbE1lc3NhZ2U6IGZ1bmN0aW9uIHByb2Nlc3NQZXJzb25hbE1lc3NhZ2UobWVzc2FnZURhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX3NpZ25NZXNzYWdlKG1lc3NhZ2VEYXRhKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNpZ25NZXNzYWdlOiBmdW5jdGlvbiBzaWduTWVzc2FnZShtZXNzYWdlRGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfc2lnbk1lc3NhZ2UobWVzc2FnZURhdGEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2lnblBlcnNvbmFsTWVzc2FnZTogZnVuY3Rpb24gc2lnblBlcnNvbmFsTWVzc2FnZShtZXNzYWdlRGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfc2lnbk1lc3NhZ2UobWVzc2FnZURhdGEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcnBjVXJsOiBycGNVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgVHJlem9yQ29ubmVjdC5vbihERVZJQ0VfRVZFTlQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gREVWSUNFLkRJU0NPTk5FQ1QpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgcmVzZXRXYWxsZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICB3YWxsZXROYW1lOiAnVHJlem9yJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3ZpZGVyLnNldFBhdGggPSBzZXRQYXRoO1xuICAgICAgICAgICAgcHJvdmlkZXIuZFBhdGggPSBkUGF0aDtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVuYWJsZSA9IGVuYWJsZTtcbiAgICAgICAgICAgIHByb3ZpZGVyLnNldFByaW1hcnlBY2NvdW50ID0gc2V0UHJpbWFyeUFjY291bnQ7XG4gICAgICAgICAgICBwcm92aWRlci5nZXRQcmltYXJ5QWRkcmVzcyA9IGdldFByaW1hcnlBZGRyZXNzO1xuICAgICAgICAgICAgcHJvdmlkZXIuZ2V0QWNjb3VudHMgPSBfZ2V0QWNjb3VudHM7XG4gICAgICAgICAgICBwcm92aWRlci5nZXRNb3JlQWNjb3VudHMgPSBnZXRNb3JlQWNjb3VudHM7XG4gICAgICAgICAgICBwcm92aWRlci5nZXRCYWxhbmNlID0gZ2V0QmFsYW5jZTtcbiAgICAgICAgICAgIHByb3ZpZGVyLmdldEJhbGFuY2VzID0gZ2V0QmFsYW5jZXM7XG4gICAgICAgICAgICBwcm92aWRlci5zZW5kID0gcHJvdmlkZXIuc2VuZEFzeW5jO1xuICAgICAgICAgICAgcHJvdmlkZXIuZGlzY29ubmVjdCA9IGRpc2Nvbm5lY3Q7XG4gICAgICAgICAgICBwcm92aWRlci5pc0N1c3RvbVBhdGggPSBpc0N1c3RvbVBhdGg7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5hYnJ1cHQoXCJyZXR1cm5cIiwgcHJvdmlkZXIpO1xuXG4gICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMTMpO1xuICB9KSk7XG4gIHJldHVybiBfdHJlem9yUHJvdmlkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdHJlem9yOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bnc-onboard/dist/esm/trezor-05345fcc.js\n");

/***/ })

}]);